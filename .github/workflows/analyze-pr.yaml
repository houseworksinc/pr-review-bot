name: Reusable PR Analysis with LLM

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_call:
    inputs:
      ai_provider:
        type: string
        default: "gemini"
        required: false
        description: "AI provider to use (gemini, claude, openai, mistral)"
    secrets:
      GOOGLE_API_KEY:
        required: false
      ANTHROPIC_API_KEY:
        required: false
      OPENAI_API_KEY:
        required: false
      MISTRAL_API_KEY:
        required: false

jobs:
  analyze_pr:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup GitHub CLI
        run: |
          gh auth setup-git
          gh auth status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch PR Files and Diff
        id: pr_diff
        run: |
          # Get PR diff with line numbers
          gh pr diff ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --patch > pr_diff.txt

          # Get list of changed files
          gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json files --jq '.files[].path' > changed_files.txt

          # Create context about the changes
          {
            echo "Changed files:"
            cat changed_files.txt
            echo -e "\nDiff content:"
            cat pr_diff.txt
          } > pr_context.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze PR
        id: analyze_pr
        run: |
          # Read the prompt template
          PROMPT_TEMPLATE=$(cat .github/workflows/prompt_template.txt)
          
          # Combine template with PR context and escape for JSON
          FULL_PROMPT=$(printf "%s\n\nHere are the changes:\n%s" "$PROMPT_TEMPLATE" "$(cat pr_context.txt)")
          ESCAPED_PROMPT=$(echo "$FULL_PROMPT" | jq -Rs .)
          
          # Prepare the request JSON and set API_URL/API_KEY based on provider using if/elif
          if [ "${{ inputs.ai_provider }}" = "gemini" ]; then
            API_KEY="${{ secrets.GOOGLE_API_KEY }}"
            API_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=$API_KEY"
            cat > request.json <<EOF
            {
              "contents": [{
              "parts": [{
                "text": ${ESCAPED_PROMPT}
              }]
              }],
              "generationConfig": {
                "temperature": 0.7,
                "topK": 40,
                "topP": 0.95,
                "maxOutputTokens": 2048
              }
            }
            EOF
          elif [ "${{ inputs.ai_provider }}" = "claude" ]; then
            API_KEY="${{ secrets.ANTHROPIC_API_KEY }}"
            API_URL="https://api.anthropic.com/v1/messages"
            cat > request.json <<EOF
            {
              "model": "claude-3-opus-20240229",
              "messages": [{
                "role": "user",
                "content": ${ESCAPED_PROMPT}
              }],
              "max_tokens": 2048
            }
            EOF
          elif [ "${{ inputs.ai_provider }}" = "openai" ]; then
            API_KEY="${{ secrets.OPENAI_API_KEY }}"
            API_URL="https://api.openai.com/v1/chat/completions"
            cat > request.json <<EOF
            {
              "model": "gpt-4",
              "messages": [{
                "role": "user",
                "content": ${ESCAPED_PROMPT}
              }],
              "max_tokens": 2048
            }
            EOF
                      elif [ "${{ inputs.ai_provider }}" = "mistral" ]; then
                        API_KEY="${{ secrets.MISTRAL_API_KEY }}"
                        API_URL="https://api.mistral.ai/v1/chat/completions"
                        cat > request.json <<EOF
            {
              "model": "mistral-large",
              "messages": [{
                "role": "user",
                "content": ${ESCAPED_PROMPT}
              }],
              "max_tokens": 2048
            }
            EOF
          else
            echo "Unsupported AI provider: ${{ inputs.ai_provider }}"
            exit 1
          fi
          
          # Make the API call
          RESPONSE=$(curl -s -X POST "$API_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d @request.json)
          
          # Extract generated text using if statements
          if [ "${{ inputs.ai_provider }}" = "gemini" ]; then
            REVIEW_CONTENT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text')
          elif [ "${{ inputs.ai_provider }}" = "claude" ]; then
            REVIEW_CONTENT=$(echo "$RESPONSE" | jq -r '.content[0].text')
          elif [ "${{ inputs.ai_provider }}" = "openai" ] || [ "${{ inputs.ai_provider }}" = "mistral" ]; then
            REVIEW_CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          fi
          
          # Check for errors
          if [ -z "$REVIEW_CONTENT" ] || [ "$REVIEW_CONTENT" = "null" ]; then
            echo "Error or empty response from ${{ inputs.ai_provider }} API."
            exit 1
          fi
          
          # Save and parse content for debugging/posting
          echo "$REVIEW_CONTENT" > review_content.txt
          echo "$REVIEW_CONTENT" | grep -E 'FILE:|LINE:|COMMENT:' > comments.txt
          
          # Format the result for posting
          cat <<EOF >> $GITHUB_ENV
          RESULT<<EOFMARKER
          # 🤖 Automated PR Review (${{ inputs.ai_provider }})

          $REVIEW_CONTENT

          ---
          _Generated by PR Review Bot_ | [📝 Report Issues](https://github.com/houseworksinc/pr-review-bot/issues)
          EOFMARKER
          EOF

      - name: Comment on PR
        uses: mshick/add-pr-comment@v2
        with:
          message: ${{ env.RESULT }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse Comments
        id: parse_comments
        run: |
          # Create a JSON array of comments
          comment_json="[]"
          while IFS= read -r line; do
            if [[ "$line" == FILE:* ]]; then
              FILE_PATH=$(echo "$line" | cut -d' ' -f2-)
            elif [[ "$line" == LINE:* ]]; then
              LINE_NUMBER=$(echo "$line" | cut -d' ' -f2-)
            elif [[ "$line" == COMMENT:* ]]; then
              COMMENT=$(echo "$line" | cut -d' ' -f2-)
              COMMENT_JSON=$(jq -n --arg body "$COMMENT" --arg path "$FILE_PATH" --argjson line "$LINE_NUMBER" '{body: $body, path: $path, line: $line, side: "RIGHT"}')
              comment_json=$(echo "$comment_json" | jq --argjson comment "$COMMENT_JSON" '. += [$comment]')
            fi
          done < comments.txt
          echo "comments=$comment_json" >> $GITHUB_OUTPUT

      - name: Post Line Comments
        run: |
          comments='${{ steps.parse_comments.outputs.comments }}'
          for comment in $(echo "$comments" | jq -c '.[]'); do
            curl -s -X POST "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/comments" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "$comment"
          done
