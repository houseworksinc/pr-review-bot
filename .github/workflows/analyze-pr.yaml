name: Reusable PR Analysis with LLM

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_call:
    secrets:
      GOOGLE_API_KEY:
        required: true

jobs:
  analyze_pr:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup GitHub CLI
        run: |
          gh auth setup-git
          gh auth status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch PR Files and Diff
        id: pr_diff
        run: |
          # Get PR diff with line numbers
          gh pr diff ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --patch > pr_diff.txt
          
          # Get list of changed files
          gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json files --jq '.files[].path' > changed_files.txt
          
          # Create context about the changes
          {
            echo "Changed files:"
            cat changed_files.txt
            echo -e "\nDiff content:"
            cat pr_diff.txt
          } > pr_context.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze PR with Gemini
        id: analyze_pr
        run: |
          # Create the prompt template
          cat > prompt_template.txt << 'EOF'
          You are an expert code reviewer. Analyze these code changes thoroughly and provide specific, actionable feedback. Focus on code quality, security, and maintainability. Be concise but comprehensive. If reviewing infrastructure code, pay special attention to security configurations and best practices.

          Review this PR and structure your analysis as follows:

          ## ðŸ“ Summary
          - Core changes and purpose
          - Files affected
          - Impact assessment
          - Breaking changes (if any)

          ## ðŸ” Technical Analysis
          - Implementation quality
          - Logic issues/bugs
          - Error handling
          - Performance implications
          - Test coverage
          - Resource management (if applicable)

          ## ðŸ”’ Security Review
          - Security vulnerabilities
          - Access control issues
          - Data protection
          - Input validation
          - Sensitive data exposure
          - Configuration risks

          ## ðŸ’¡ Code Quality
          - Naming conventions
          - Code organization
          - Documentation completeness
          - Maintainability
          - Best practices adherence
          - Potential refactoring needs

          ## ðŸŽ¯ Recommendations
          - Specific improvements
          - Alternative approaches
          - Additional tests needed
          - Documentation updates

          Keep sections focused and actionable. Mark 'No issues identified' if a section has no concerns.
          EOF
          
          # Combine template with PR context and escape for JSON
          PROMPT_TEMPLATE=$(cat prompt_template.txt)
          FULL_PROMPT=$(printf "%s\n\nHere are the changes:\n%s" "$PROMPT_TEMPLATE" "$(cat pr_context.txt)")
          ESCAPED_PROMPT=$(echo "$FULL_PROMPT" | jq -Rs .)
          
          # Make the API call to Gemini
          cat > request.json << EOF
          {
            "contents": [{
              "parts":[{
                "text": ${ESCAPED_PROMPT}
              }]
            }],
            "generationConfig": {
              "temperature": 0.7,
              "topK": 40,
              "topP": 0.95,
              "maxOutputTokens": 2048
            }
          }
          EOF
          
          RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${{ secrets.GOOGLE_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d @request.json)

          # Check for API errors
          if [ "$(echo "$RESPONSE" | jq -r '.error')" != "null" ]; then
            echo "Error from Gemini API: $(echo "$RESPONSE" | jq -r '.error.message')"
            exit 1
          fi

          # Extract the generated text from response
          REVIEW_CONTENT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text')

          # Format and save the response
          cat > result.txt << EOF
          RESULT<<EOFMARKER
          # ðŸ¤– Automated PR Review

          $REVIEW_CONTENT

          ---
          _Generated by PR Review Bot (Gemini)_ | [ðŸ“ Report Issues](https://github.com/houseworksinc/pr-review-bot/issues)
          EOFMARKER
          EOF
          
          cat result.txt >> $GITHUB_ENV

      - name: Comment on PR
        uses: mshick/add-pr-comment@v2
        with:
          message: ${{ env.RESULT }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Add Line Comments
        run: |
          # Parse the review content for line-specific comments
          # This is a placeholder for the logic to parse and extract line comments
          # You need to implement the logic to parse the review content and extract line numbers and comments
          # For example, you can use regex or a custom parser to extract line numbers and comments
          # Then, use the GitHub API to add line comments

          # Example of adding a line comment using the GitHub API
          # Replace with actual line number, file path, and comment
          LINE_NUMBER=10
          FILE_PATH="src/main.py"
          COMMENT="This line needs improvement."

          curl -s -X POST "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/comments" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
          {
            "body": "$COMMENT",
            "path": "$FILE_PATH",
            "line": $LINE_NUMBER,
            "side": "RIGHT"
          }
          EOF