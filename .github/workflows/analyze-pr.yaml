name: Reusable PR Analysis with LLM

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_call:
    secrets:
      GOOGLE_API_KEY:
        required: true

jobs:
  analyze_pr:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup GitHub CLI
        run: |
          gh auth setup-git
          gh auth status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch PR Files and Diff
        id: pr_diff
        run: |
          # Get PR diff with line numbers
          gh pr diff ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --patch > pr_diff.txt
          
          # Get list of changed files
          gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json files --jq '.files[].path' > changed_files.txt
          
          # Create context about the changes
          {
            echo "Changed files:"
            cat changed_files.txt
            echo -e "\nDiff content:"
            cat pr_diff.txt
          } > pr_context.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze PR with Gemini
        id: analyze_pr
        run: |
          # Create the prompt template
          cat > prompt_template.txt << 'EOF'
          You are an expert code reviewer. Analyze these code changes thoroughly and provide specific, actionable feedback. Focus on code quality, security, and maintainability. Be concise but comprehensive. If reviewing infrastructure code, pay special attention to security configurations and best practices.

          Review this PR and structure your analysis as follows:

          ## ðŸ“ Summary
          - Core changes and purpose
          - Files affected
          - Impact assessment
          - Breaking changes (if any)

          ## ðŸ” Technical Analysis
          - Implementation quality
          - Logic issues/bugs
          - Error handling
          - Performance implications
          - Test coverage
          - Resource management (if applicable)

          ## ðŸ”’ Security Review
          - Security vulnerabilities
          - Access control issues
          - Data protection
          - Input validation
          - Sensitive data exposure
          - Configuration risks

          ## ðŸ’¡ Code Quality
          - Naming conventions
          - Code organization
          - Documentation completeness
          - Maintainability
          - Best practices adherence
          - Potential refactoring needs

          ## ðŸŽ¯ Recommendations
          - Specific improvements
          - Alternative approaches
          - Additional tests needed
          - Documentation updates

          For each issue or suggestion, provide the following format:
          FILE: <file_path>
          LINE: <line_number>
          COMMENT: <your_comment>

          Keep sections focused and actionable. Mark 'No issues identified' if a section has no concerns.
          EOF
          
          # Combine template with PR context and escape for JSON
          PROMPT_TEMPLATE=$(cat prompt_template.txt)
          FULL_PROMPT=$(printf "%s\n\nHere are the changes:\n%s" "$PROMPT_TEMPLATE" "$(cat pr_context.txt)")
          ESCAPED_PROMPT=$(echo "$FULL_PROMPT" | jq -Rs .)
          
          # Make the API call to Gemini
          cat > request.json << EOF
          {
            "contents": [{
              "parts":[{
                "text": ${ESCAPED_PROMPT}
              }]
            }],
            "generationConfig": {
              "temperature": 0.7,
              "topK": 40,
              "topP": 0.95,
              "maxOutputTokens": 2048
            }
          }
          EOF
          
          RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${{ secrets.GOOGLE_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d @request.json)

          # Check for API errors
          if [ "$(echo "$RESPONSE" | jq -r '.error')" != "null" ]; then
            echo "Error from Gemini API: $(echo "$RESPONSE" | jq -r '.error.message')"
            exit 1
          fi

          # Extract the generated text from response
          REVIEW_CONTENT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text')

          # Save the review content for debugging
          echo "$REVIEW_CONTENT" > review_content.txt

          # Parse the review content for line-specific comments
          echo "$REVIEW_CONTENT" | grep -E 'FILE:|LINE:|COMMENT:' > comments.txt

          # Format and save the response
          cat > result.txt << EOF
          RESULT<<EOFMARKER
          # ðŸ¤– Automated PR Review

          $REVIEW_CONTENT

          ---
          _Generated by PR Review Bot (Gemini)_ | [ðŸ“ Report Issues](https://github.com/houseworksinc/pr-review-bot/issues)
          EOFMARKER
          EOF
          
          cat result.txt >> $GITHUB_ENV

      - name: Comment on PR
        uses: mshick/add-pr-comment@v2
        with:
          message: ${{ env.RESULT }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Add Line Comments
        run: |
          # Read the comments file and post line-specific comments
          while IFS= read -r line; do
            if [[ "$line" == FILE:* ]]; then
              FILE_PATH=$(echo "$line" | cut -d' ' -f2-)
            elif [[ "$line" == LINE:* ]]; then
              LINE_NUMBER=$(echo "$line" | cut -d' ' -f2-)
            elif [[ "$line" == COMMENT:* ]]; then
              COMMENT=$(echo "$line" | cut -d' ' -f2-)
              # Post the comment using the GitHub API
              curl -s -X POST "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/comments" \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/json" \
                -d @- <<EOF
              {
                "body": "$COMMENT",
                "path": "$FILE_PATH",
                "line": $LINE_NUMBER,
                "side": "RIGHT"
              }
              EOF
            fi
          done < comments.txt